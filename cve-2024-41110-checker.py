import argparse
import concurrent.futures
import getpass
import os
from fabric import Connection
from invoke import UnexpectedExit

# Banner
BANNER = r"""
 ██████╗██╗   ██╗███████╗    ██████╗  ██████╗ ██████╗ ██╗  ██╗      ██╗  ██╗ ██╗ ██╗ ██╗ ██████╗        ██████╗██╗  ██╗███████╗ ██████╗██╗  ██╗███████╗██████╗
██╔════╝██║   ██║██╔════╝    ╚════██╗██╔═████╗╚════██╗██║  ██║      ██║  ██║███║███║███║██╔═████╗      ██╔════╝██║  ██║██╔════╝██╔════╝██║ ██╔╝██╔════╝██╔══██╗
██║     ██║   ██║█████╗█████╗ █████╔╝██║██╔██║ █████╔╝███████║█████╗███████║╚██║╚██║╚██║██║██╔██║█████╗██║     ███████║█████╗  ██║     █████╔╝ █████╗  ██████╔╝
██║     ╚██╗ ██╔╝██╔══╝╚════╝██╔═══╝ ████╔╝██║██╔═══╝ ╚════██║╚════╝╚════██║ ██║ ██║ ██║████╔╝██║╚════╝██║     ██╔══██║██╔══╝  ██║     ██╔═██╗ ██╔══╝  ██╔══██╗
╚██████╗ ╚████╔╝ ███████╗    ███████╗╚██████╔╝███████╗     ██║           ██║ ██║ ██║ ██║╚██████╔╝      ╚██████╗██║  ██║███████╗╚██████╗██║  ██╗███████╗██║  ██║
 ╚═════╝  ╚═══╝  ╚══════╝    ╚══════╝ ╚═════╝ ╚══════╝     ╚═╝           ╚═╝ ╚═╝ ╚═╝ ╚═╝ ╚═════╝        ╚═════╝╚═╝  ╚═╝╚══════╝ ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝
                                               Created by vvpoglazov (https://github.com/vvpoglazov)
"""

AFFECTED_VERSIONS = [
    "v19.03.15 and earlier",
    "v20.10.27 and earlier",
    "v23.0.14 and earlier",
    "v24.0.9 and earlier",
    "v25.0.5 and earlier",
    "v26.0.2 and earlier",
    "v26.1.4 and earlier",
    "v27.0.3 and earlier",
    "v27.1.0"
]

def parse_version(version_str):
    return tuple(map(int, version_str.split('.')))

def is_vulnerable(version_str):
    version = parse_version(version_str)
    vulnerable_versions = [
        (19, 3, 15), (20, 10, 27), (23, 0, 14), (24, 0, 9),
        (25, 0, 5), (26, 0, 2), (26, 1, 4), (27, 0, 3), (27, 1, 0)
    ]
    return any(version <= v for v in vulnerable_versions)

def check_docker(host, username, password=None, key_filename=None, output_dir=None):
    output_file = os.path.join(output_dir, f"{host}_docker_info.txt")

    try:
        connect_kwargs = {}
        if password:
            connect_kwargs["password"] = password
        if key_filename:
            connect_kwargs["key_filename"] = key_filename

        with Connection(host, user=username, connect_kwargs=connect_kwargs) as conn:
            # Check Docker version
            result = conn.run("docker version --format '{{.Server.Version}}'", hide=True, warn=True)
            if result.failed:
                with open(output_file, 'w') as f:
                    f.write(f"Docker is not running or not installed on {host}\n")
                return {"host": host, "status": "not_running", "version": None, "authz_used": False}

            docker_version = result.stdout.strip()

            # Check for AuthZ plugin
            commands = [
                "grep -q 'authorization-plugins' /etc/docker/daemon.json && echo 'Found in daemon.json' || echo 'Not found in daemon.json'",
                "grep -q 'authorization-plugins' /lib/systemd/system/docker.service && echo 'Found in docker.service' || echo 'Not found in docker.service'",
                "ps aux | grep dockerd | grep -q 'authorization-plugin' && echo 'Found in running processes' || echo 'Not found in running processes'"
            ]

            authz_used = False
            results = []
            for cmd in commands:
                result = conn.run(cmd, hide=True, warn=True)
                results.append(result.stdout.strip())
                if 'Found' in result.stdout:
                    authz_used = True

            # Write results
            with open(output_file, 'w') as f:
                f.write(f"Docker CE version: {docker_version}\n")
                f.write(f"AuthZ plugin check results:\n")
                for result in results:
                    f.write(f"  {result}\n")

                if authz_used and is_vulnerable(docker_version):
                    f.write("WARNING: This host is particularly vulnerable due to the use of AuthZ plugin and an affected Docker version.\n")

            return {
                "host": host,
                "status": "vulnerable" if authz_used and is_vulnerable(docker_version) else "ok",
                "version": docker_version,
                "authz_used": authz_used
            }

    except Exception as e:
        with open(output_file, 'w') as f:
            f.write(f"Error connecting to or checking {host}: {str(e)}\n")
        return {"host": host, "status": "error", "version": None, "authz_used": False}

def generate_summary_report(results, output_dir):
    summary_file = os.path.join(output_dir, "summary_report.txt")
    vulnerable_hosts = [r for r in results if r["status"] == "vulnerable"]
    error_hosts = [r for r in results if r["status"] == "error"]
    ok_hosts = [r for r in results if r["status"] == "ok"]
    not_running_hosts = [r for r in results if r["status"] == "not_running"]

    report_content = [BANNER]

    report_content.append("Affected Versions:")
    for version in AFFECTED_VERSIONS:
        report_content.append(f"- {version}")
    report_content.append("")

    report_content.append(f"Total hosts checked: {len(results)}")
    report_content.append(f"Vulnerable hosts: {len(vulnerable_hosts)}")
    report_content.append(f"Hosts OK: {len(ok_hosts)}")
    report_content.append(f"Hosts without Docker running: {len(not_running_hosts)}")
    report_content.append(f"Hosts with errors: {len(error_hosts)}\n")

    if vulnerable_hosts:
        report_content.append("Vulnerable Hosts:")
        for host in vulnerable_hosts:
            report_content.append(f"- {host['host']} (Version: {host['version']})")
        report_content.append("")

    if not_running_hosts:
        report_content.append("Hosts without Docker running:")
        for host in not_running_hosts:
            report_content.append(f"- {host['host']}")
        report_content.append("")

    if error_hosts:
        report_content.append("Hosts with Errors:")
        for host in error_hosts:
            report_content.append(f"- {host['host']}")
        report_content.append("")

    report_content.append("Remediation plan:")
    report_content.append("* If you are running an affected version, update to the most recent patched version.")
    report_content.append("* Mitigation if unable to update immediately:")
    report_content.append("   * Avoid using AuthZ plugins.")
    report_content.append("   * Restrict access to the Docker API to trusted parties, following the principle of least privilege.")

    with open(summary_file, 'w') as f:
        f.write("\n".join(report_content))

    return summary_file, report_content

def main():
    print(BANNER)
    
    parser = argparse.ArgumentParser(description="Check Docker security on multiple hosts for CVE-2024–41110.")
    parser.add_argument("username", help="SSH username")
    parser.add_argument("hosts_file", help="File containing list of hosts")
    parser.add_argument("output_dir", help="Directory to store output files")
    parser.add_argument("-k", "--key", help="Path to SSH private key file for authentication")
    args = parser.parse_args()

    if not os.path.exists(args.hosts_file):
        print(f"Error: Hosts file {args.hosts_file} does not exist.")
        return

    os.makedirs(args.output_dir, exist_ok=True)

    password = None
    if not args.key:
        password = getpass.getpass("Enter SSH password: ")

    with open(args.hosts_file, 'r') as f:
        hosts = [line.strip() for line in f if line.strip() and not line.startswith('#')]

    results = []

    with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
        future_to_host = {executor.submit(check_docker, host, args.username, password, args.key, args.output_dir): host for host in hosts}
        for future in concurrent.futures.as_completed(future_to_host):
            host = future_to_host[future]
            try:
                result = future.result()
                results.append(result)
                print(f"Completed check for {host}")
            except Exception as exc:
                print(f"Check for {host} generated an exception: {exc}")

    summary_file, report_content = generate_summary_report(results, args.output_dir)

    print(f"\nScript completed. Docker information for all hosts has been stored in {args.output_dir}")
    print(f"Summary report has been generated: {summary_file}")
    print("\nDocker Security Check Summary Report:")
    print("=====================================")
    print("\n".join(report_content[1:]))  # Skip the banner in the CLI output as it's already printed at the start

if __name__ == "__main__":
    main()
